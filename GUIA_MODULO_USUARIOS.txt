# ğŸ“š **GuÃ­a Completa: MÃ³dulo de Usuarios NestJS - Paso a Paso**

Te explico cÃ³mo funciona todo el mÃ³dulo de usuarios que hemos construido, siguiendo las mejores prÃ¡cticas de arquitectura hexagonal y Domain-Driven Design (DDD).

## **ğŸ—ï¸ 1. ARQUITECTURA GENERAL**

```
src/users/
â”œâ”€â”€ users.module.ts                    # MÃ³dulo principal
â”œâ”€â”€ application/                       # Capa de aplicaciÃ³n
â”‚   â”œâ”€â”€ dto/                          # Data Transfer Objects
â”‚   â”‚   â”œâ”€â”€ create.user.dto.ts        # DTO para crear usuario
â”‚   â”‚   â”œâ”€â”€ update.user.dto.ts        # DTO para actualizar usuario
â”‚   â”‚   â”œâ”€â”€ login.dto.ts              # DTO para login
â”‚   â”‚   â””â”€â”€ user.response.dto.ts      # DTO para respuestas
â”‚   â””â”€â”€ services/
â”‚       â””â”€â”€ user.service.ts           # Casos de uso/Servicios de aplicaciÃ³n
â”œâ”€â”€ domain/                           # Capa de dominio
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â””â”€â”€ user.entity.ts            # Entidad de dominio
â”‚   â””â”€â”€ interfaces/
â”‚       â””â”€â”€ user.repository.interface.ts # Contrato del repositorio
â”œâ”€â”€ infrastructure/                    # Capa de infraestructura
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ user.controller.ts        # Endpoints de usuarios
â”‚   â”‚   â”œâ”€â”€ admin.controller.ts       # Endpoints de administraciÃ³n
â”‚   â”‚   â””â”€â”€ public.controller.ts      # Endpoints pÃºblicos
â”‚   â””â”€â”€ repositories/
â”‚       â””â”€â”€ prisma-user.repository.ts # ImplementaciÃ³n con Prisma
â””â”€â”€ utils/                            # Utilidades (si las hay)
```

## **ğŸ” 2. PRINCIPIOS ARQUITECTÃ“NICOS APLICADOS**

### **A. Arquitectura Hexagonal (Puertos y Adaptadores)**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     CONTROLLERS         â”‚ â† Puerto de entrada (HTTP)
â”‚   (Infrastructure)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      SERVICES           â”‚ â† Casos de uso
â”‚    (Application)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ENTITIES           â”‚ â† LÃ³gica de negocio
â”‚      (Domain)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    REPOSITORIES         â”‚ â† Puerto de salida (Base de datos)
â”‚   (Infrastructure)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **B. Domain-Driven Design (DDD)**
- **Domain**: Contiene la lÃ³gica de negocio pura
- **Application**: Orquesta los casos de uso
- **Infrastructure**: Detalles tÃ©cnicos de implementaciÃ³n

## **ğŸ“‹ 3. PASO A PASO: CONSTRUCCIÃ“N DEL MÃ“DULO**

### **Paso 1: Definir la Entidad de Dominio**

```typescript
// domain/entities/user.entity.ts
// Esta es la representaciÃ³n "perfecta" de un usuario en nuestro dominio

export interface CreateUser {
  email: string;
  password: string;
  name: string;
  role: string;
  avatarUrl?: string;
}

export interface User1 {
  id: string;
  email: string;
  password: string;
  name: string;
  avatarUrl?: string | null;
  role: string;
  createdAt: Date;
  updatedAt: Date;
}

export class User {
  constructor(
    public readonly id: string,
    public readonly email: string,
    public readonly password: string,
    public readonly name: string,
    public readonly role: string,
    public readonly avatarUrl?: string | null,
    public readonly createdAt?: Date,
    public readonly updatedAt?: Date,
  ) {}

  // âœ¨ MÃ©todo de factorÃ­a: Convierte datos de BD a entidad de dominio
  static fromPersistence(raw: any): User {
    return new User(
      raw.id,
      raw.email,
      raw.password,
      raw.name,
      raw.role,
      raw.avatarUrl,
      raw.createdAt,
      raw.updatedAt,
    );
  }

  // âœ¨ MÃ©todo de conversiÃ³n: Entidad de dominio a datos de BD
  toPersistence(): any {
    return {
      id: this.id,
      email: this.email,
      password: this.password,
      name: this.name,
      role: this.role,
      avatarUrl: this.avatarUrl,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  // ğŸ”’ LÃ³gica de negocio: Â¿El usuario es administrador?
  isAdmin(): boolean {
    return this.role === 'admin';
  }

  // ğŸ”’ LÃ³gica de negocio: Â¿El usuario puede moderar?
  canModerate(): boolean {
    return this.role === 'admin' || this.role === 'moderator';
  }
}
```

### **Paso 2: Definir el Contrato del Repositorio**

```typescript
// domain/interfaces/user.repository.interface.ts
// Esto define QUÃ‰ operaciones necesitamos, no CÃ“MO implementarlas

export interface IUserRepository {
  // ğŸ“ Operaciones CRUD bÃ¡sicas
  create(userEntity: CreateUser): Promise<User1>;
  update(id: string, userEntity: Partial<User>): Promise<User | null>;
  delete(id: string): Promise<boolean>;
  
  // ğŸ” Operaciones de consulta
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  findAll(): Promise<User[]>;
}

// âœ¨ Ventajas de esta interfaz:
// 1. Desacoplamiento: El dominio no conoce Prisma, MongoDB, etc.
// 2. Testabilidad: Podemos crear mocks fÃ¡cilmente
// 3. Flexibilidad: Cambiar de BD sin afectar lÃ³gica de negocio
```

### **Paso 3: Crear los DTOs (Data Transfer Objects)**

```typescript
// application/dto/create.user.dto.ts
// Define quÃ© datos necesitamos para crear un usuario

export class CreateUserDto {
  email: string;      // âœ… Requerido
  password: string;   // âœ… Requerido  
  name: string;       // âœ… Requerido
  role: string;       // âœ… Requerido (user, admin, moderator)
  avatarUrl?: string; // â“ Opcional
}

// application/dto/update.user.dto.ts
// Define quÃ© datos se pueden actualizar (todos opcionales)

export class UpdateUserDto {
  email?: string;     // â“ Opcional
  password?: string;  // â“ Opcional
  name?: string;      // â“ Opcional
  role?: string;      // â“ Opcional
  avatarUrl?: string; // â“ Opcional
}

// application/dto/user.response.dto.ts
// Define quÃ© datos enviamos al cliente (sin password)

export class UserResponseDto {
  id: string;
  email: string;
  name: string;
  role: string;
  avatarUrl?: string;
  createdAt: Date;
  updatedAt: Date;
  
  // ğŸš« Nota: NO incluimos password por seguridad
}
```

### **Paso 4: Implementar el Repositorio con Prisma**

```typescript
// infrastructure/repositories/prisma-user.repository.ts
// Implementa CÃ“MO guardamos/obtenemos datos usando Prisma

@Injectable()
export class PrismaUserRepository implements IUserRepository {
  constructor(private readonly prisma: PrismaService) {}

  // ğŸ“ CREATE: Crear nuevo usuario
  async create(userEntity: CreateUser): Promise<User1> {
    try {
      const createdPrismaUser = await this.prisma.user.create({
        data: userEntity, // Prisma crea automÃ¡ticamente id, createdAt, updatedAt
      });
      return createdPrismaUser as User1;
    } catch (error) {
      // ğŸš¨ Manejo especÃ­fico de errores de Prisma
      if (error instanceof PrismaClientKnownRequestError && error.code === 'P2002') {
        // P2002 = ViolaciÃ³n de restricciÃ³n Ãºnica (email duplicado)
        throw new Error(`Conflict: User with email "${userEntity.email}" already exists.`);
      }
      throw new Error(`Failed to create user: ${error.message}`);
    }
  }

  // ğŸ“ UPDATE: Actualizar usuario existente
  async update(id: string, userEntity: Partial<User>): Promise<User | null> {
    try {
      // ğŸ¯ Solo actualizamos campos que tienen valor
      const updateData: any = {};
      if (userEntity.email) updateData.email = userEntity.email;
      if (userEntity.password) updateData.password = userEntity.password;
      if (userEntity.name) updateData.name = userEntity.name;
      if (userEntity.avatarUrl) updateData.avatarUrl = userEntity.avatarUrl;
      if (userEntity.role) updateData.role = userEntity.role;

      const updatedPrismaUser = await this.prisma.user.update({
        where: { id },
        data: updateData,
      });
      
      return User.fromPersistence(updatedPrismaUser);
    } catch (error) {
      if (error instanceof PrismaClientKnownRequestError && error.code === 'P2025') {
        // P2025 = Registro no encontrado
        return null;
      }
      throw new Error(`Failed to update user with ID ${id}: ${error.message}`);
    }
  }

  // ğŸ—‘ï¸ DELETE: Eliminar usuario
  async delete(id: string): Promise<boolean> {
    try {
      await this.prisma.user.delete({ where: { id } });
      return true; // âœ… EliminaciÃ³n exitosa
    } catch (error) {
      if (error instanceof PrismaClientKnownRequestError && error.code === 'P2025') {
        return false; // âŒ Usuario no encontrado
      }
      throw new Error(`Failed to delete user with ID ${id}: ${error.message}`);
    }
  }

  // ğŸ” FIND BY ID: Buscar por ID
  async findById(id: string): Promise<User | null> {
    try {
      const prismaUser = await this.prisma.user.findUnique({ where: { id } });
      return prismaUser ? User.fromPersistence(prismaUser) : null;
    } catch (error) {
      throw new Error(`Failed to retrieve user by ID ${id}: ${error.message}`);
    }
  }

  // ğŸ” FIND BY EMAIL: Buscar por email (para login)
  async findByEmail(email: string): Promise<User | null> {
    try {
      const prismaUser = await this.prisma.user.findUnique({ where: { email } });
      return prismaUser ? User.fromPersistence(prismaUser) : null;
    } catch (error) {
      throw new Error(`Failed to retrieve user by email ${email}: ${error.message}`);
    }
  }

  // ğŸ“‹ FIND ALL: Obtener todos los usuarios
  async findAll(): Promise<User[]> {
    try {
      const prismaUsers = await this.prisma.user.findMany();
      return prismaUsers.map(User.fromPersistence); // Convertir cada uno a entidad
    } catch (error) {
      throw new Error(`Failed to retrieve all users: ${error.message}`);
    }
  }
}
```

### **Paso 5: Crear el Servicio de AplicaciÃ³n (Casos de Uso)**

```typescript
// application/services/user.service.ts
// Orquesta los casos de uso del negocio

@Injectable()
export class UserService {
  constructor(
    @Inject('IUserRepository') // ğŸ”Œ InyecciÃ³n por interfaz, no implementaciÃ³n
    private readonly userRepository: IUserRepository,
  ) {}

  // ğŸ¯ CASO DE USO: Crear nuevo usuario
  async createUser(createDto: CreateUserDto): Promise<User1> {
    // ğŸ” Validaciones de negocio podrÃ­an ir aquÃ­
    // Por ejemplo: validar formato de email, fortaleza de password, etc.
    
    return this.userRepository.create(createDto);
  }

  // ğŸ¯ CASO DE USO: Actualizar usuario existente
  async updateUser(id: string, updateDto: UpdateUserDto): Promise<User> {
    // ğŸ” Verificar que el usuario existe
    const existingUser = await this.userRepository.findById(id);
    if (!existingUser) {
      throw new NotFoundException(`Usuario con ID "${id}" no encontrado durante la operaciÃ³n de actualizaciÃ³n.`);
    }

    try {
      const updatedUser = await this.userRepository.update(id, updateDto);
      if (!updatedUser) {
        throw new NotFoundException(`Usuario con ID "${id}" no encontrado durante la operaciÃ³n de actualizaciÃ³n.`);
      }
      return updatedUser;
    } catch (error) {
      if (error.message.includes('email already in use')) {
        throw new ConflictException(`No se puede actualizar el usuario: el email "${updateDto.email}" ya estÃ¡ en uso.`);
      }
      throw new Error('No se pudo procesar la solicitud de actualizaciÃ³n de usuario.');
    }
  }

  // ğŸ¯ CASO DE USO: Buscar usuario por ID
  async findById(id: string): Promise<User> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      throw new NotFoundException(`Usuario con ID "${id}" no encontrado.`);
    }
    return user;
  }

  // ğŸ¯ CASO DE USO: Buscar usuario por email (usado en login)
  async findByEmail(email: string): Promise<User> {
    const user = await this.userRepository.findByEmail(email);
    if (!user) {
      throw new NotFoundException(`Usuario con email "${email}" no encontrado.`);
    }
    return user;
  }

  // ğŸ¯ CASO DE USO: Eliminar usuario
  async deleteUser(id: string): Promise<boolean> {
    try {
      const deleted = await this.userRepository.delete(id);
      if (!deleted) {
        throw new NotFoundException(`Usuario con ID "${id}" no encontrado para eliminaciÃ³n.`);
      }
      return true;
    } catch (error) {
      throw new Error('No se pudo procesar la solicitud de eliminaciÃ³n de usuario.');
    }
  }

  // ğŸ¯ CASO DE USO: Obtener todos los usuarios
  async findAll(): Promise<User[]> {
    return this.userRepository.findAll();
  }
}
```

### **Paso 6: Crear los Controladores (Puertos de Entrada)**

```typescript
// infrastructure/controllers/user.controller.ts
// Maneja requests HTTP relacionadas con usuarios

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}
  
  // ğŸ”“ ENDPOINT PÃšBLICO: Crear usuario (registro)
  @Public() // Cualquiera puede registrarse
  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.userService.createUser(createUserDto);
  }

  // ğŸ”’ ENDPOINT PROTEGIDO: Obtener perfil del usuario autenticado
  @Get('profile')
  getProfile(@Request() req: any) {
    // req.user viene del AuthGuard
    return this.userService.findByEmail(req.user.username);
  }

  // ğŸ‘‘ ENDPOINT PARA ADMIN: Ver informaciÃ³n de administradores solamente
  @Roles(Role.ADMIN)
  @Get('admin-only')
  getAdminData(@Request() req: any) {
    return {
      message: 'Este endpoint solo es accesible para administradores',
      user: req.user
    };
  }

  // ğŸ‘‘ğŸ›¡ï¸ ENDPOINT PARA ADMIN/MODERADOR: Funciones de moderaciÃ³n
  @Roles(Role.ADMIN, Role.MODERATOR)
  @Get('moderator-admin')
  getModeratorOrAdminData(@Request() req: any) {
    return {
      message: 'Este endpoint es accesible para moderadores y administradores',
      user: req.user
    };
  }

  // ğŸ‘‘ ENDPOINT PARA ADMIN: Eliminar usuarios
  @Roles(Role.ADMIN)
  @Delete(':id')
  deleteUser(@Param('id') id: string, @Request() req: any) {
    return {
      message: `Usuario ${id} eliminado por ${req.user.username}`,
      deletedBy: req.user
    };
  }

  // ğŸ”’ ENDPOINT PROTEGIDO: Actualizar perfil
  @Put('profile')
  updateProfile(@Request() req: any, @Body() updateData: any) {
    return {
      message: 'Perfil actualizado',
      user: req.user.username,
      data: updateData
    };
  }
}
```

### **Paso 7: Configurar el MÃ³dulo**

```typescript
// users.module.ts
// Ensambla todas las piezas del mÃ³dulo

@Module({
  imports: [
    PrismaModule,                    // Para acceso a base de datos
    forwardRef(() => AuthModule)     // Referencia circular con AuthModule
  ],
  controllers: [
    UserController,                  // Endpoints de usuarios
    AdminController,                 // Endpoints de administraciÃ³n
    PublicController                 // Endpoints pÃºblicos
  ],
  providers: [
    {
      provide: 'IUserRepository',    // ğŸ”Œ Registro de la interfaz
      useClass: PrismaUserRepository // ğŸ”§ Con implementaciÃ³n especÃ­fica
    },
    UserService                      // Servicio de casos de uso
  ],
  exports: [UserService]             // Para usar en otros mÃ³dulos (AuthModule)
})
export class UserModule {}
```

## **ğŸ”„ 4. FLUJO COMPLETO DE UNA OPERACIÃ“N**

### **Ejemplo: Crear un nuevo usuario**

```
1. ğŸ“¥ POST /users
   Body: { "email": "user@test.com", "password": "123456", "name": "Test User", "role": "user" }

2. ğŸ” AuthGuard verifica:
   â”œâ”€â”€ Â¿Tiene @Public()? â†’ SÃ âœ…
   â””â”€â”€ Permite continuar sin verificar token

3. ğŸ›¡ï¸ RoleGuard verifica:
   â”œâ”€â”€ Â¿Tiene @Public()? â†’ SÃ âœ…  
   â””â”€â”€ Permite continuar sin verificar roles

4. ğŸ¯ UserController.create() se ejecuta:
   â”œâ”€â”€ Recibe CreateUserDto
   â””â”€â”€ Llama a userService.createUser(dto)

5. âš™ï¸ UserService.createUser() se ejecuta:
   â”œâ”€â”€ PodrÃ­a aplicar validaciones de negocio
   â””â”€â”€ Llama a userRepository.create(dto)

6. ğŸ’¾ PrismaUserRepository.create() se ejecuta:
   â”œâ”€â”€ Convierte DTO a datos de Prisma
   â”œâ”€â”€ Ejecuta prisma.user.create()
   â”œâ”€â”€ Maneja errores especÃ­ficos (email duplicado)
   â””â”€â”€ Retorna User1

7. ğŸ“¤ Respuesta se envÃ­a al cliente:
   {
     "id": "uuid-generado",
     "email": "user@test.com",
     "name": "Test User",
     "role": "user",
     "createdAt": "2025-07-14T10:30:00.000Z",
     "updatedAt": "2025-07-14T10:30:00.000Z"
   }
```

## **ğŸ¯ 5. VENTAJAS DE ESTA ARQUITECTURA**

### **âœ… SeparaciÃ³n de Responsabilidades**
- **Domain**: Solo lÃ³gica de negocio pura
- **Application**: Casos de uso y orquestaciÃ³n
- **Infrastructure**: Detalles tÃ©cnicos (HTTP, BD, etc.)

### **âœ… Testabilidad**
```typescript
// FÃ¡cil crear mocks para testing
const mockUserRepository: IUserRepository = {
  create: jest.fn(),
  findById: jest.fn(),
  findByEmail: jest.fn(),
  // ... otros mÃ©todos
};

// Test del servicio sin tocar la BD
const userService = new UserService(mockUserRepository);
```

### **âœ… Flexibilidad**
```typescript
// Cambiar de Prisma a MongoDB sin afectar lÃ³gica de negocio
@Module({
  providers: [
    {
      provide: 'IUserRepository',
      useClass: MongoUserRepository, // En lugar de PrismaUserRepository
    },
  ],
})
```

### **âœ… Mantenibilidad**
- Cada capa tiene una responsabilidad clara
- Cambios en una capa no afectan las otras
- CÃ³digo mÃ¡s legible y organizado

### **âœ… Escalabilidad**
- FÃ¡cil agregar nuevos casos de uso
- FÃ¡cil cambiar implementaciones
- FÃ¡cil agregar nuevos endpoints

## **ğŸ”§ 6. PATRONES DE DISEÃ‘O UTILIZADOS**

### **Repository Pattern**
```typescript
// Interfaz define el contrato
interface IUserRepository {
  findById(id: string): Promise<User | null>;
}

// ImplementaciÃ³n especÃ­fica para Prisma
class PrismaUserRepository implements IUserRepository {
  async findById(id: string): Promise<User | null> {
    // ImplementaciÃ³n especÃ­fica
  }
}
```

### **Dependency Injection**
```typescript
// Servicio no conoce la implementaciÃ³n especÃ­fica
constructor(
  @Inject('IUserRepository') // Inyecta por interfaz
  private readonly userRepository: IUserRepository, // No PrismaUserRepository
) {}
```

### **Factory Pattern**
```typescript
// Crear entidades de dominio desde datos raw
static fromPersistence(raw: any): User {
  return new User(raw.id, raw.email, /* ... */);
}
```

### **DTO Pattern**
```typescript
// Separar datos de entrada/salida de entidades internas
class CreateUserDto {
  email: string;
  password: string;
  // ...
}
```

## **ğŸ“Š 7. EJEMPLO DE TESTING**

```typescript
// user.service.spec.ts
describe('UserService', () => {
  let service: UserService;
  let mockRepository: jest.Mocked<IUserRepository>;

  beforeEach(() => {
    mockRepository = {
      create: jest.fn(),
      findByEmail: jest.fn(),
      // ... otros mÃ©todos mockeados
    };

    service = new UserService(mockRepository);
  });

  describe('createUser', () => {
    it('should create a user successfully', async () => {
      // Arrange
      const createDto: CreateUserDto = {
        email: 'test@example.com',
        password: 'password123',
        name: 'Test User',
        role: 'user'
      };

      const expectedUser: User1 = {
        id: 'uuid-123',
        email: createDto.email,
        name: createDto.name,
        // ... otros campos
      };

      mockRepository.create.mockResolvedValue(expectedUser);

      // Act
      const result = await service.createUser(createDto);

      // Assert
      expect(mockRepository.create).toHaveBeenCalledWith(createDto);
      expect(result).toEqual(expectedUser);
    });

    it('should throw error when email already exists', async () => {
      // Arrange
      const createDto: CreateUserDto = { /* ... */ };
      mockRepository.create.mockRejectedValue(
        new Error('Conflict: User with email "test@example.com" already exists.')
      );

      // Act & Assert
      await expect(service.createUser(createDto)).rejects.toThrow('Conflict');
    });
  });
});
```

## **ğŸš¨ 8. MANEJO DE ERRORES**

### **A nivel de Repositorio (Errores de BD)**
```typescript
catch (error) {
  if (error instanceof PrismaClientKnownRequestError && error.code === 'P2002') {
    throw new Error(`Conflict: User with email "${userEntity.email}" already exists.`);
  }
  throw new Error(`Failed to create user: ${error.message}`);
}
```

### **A nivel de Servicio (Errores de Negocio)**
```typescript
const existingUser = await this.userRepository.findById(id);
if (!existingUser) {
  throw new NotFoundException(`Usuario con ID "${id}" no encontrado.`);
}
```

### **A nivel de Controlador (Errores HTTP)**
```typescript
// Los errores se manejan automÃ¡ticamente por el AuthExceptionFilter
// que convierte excepciones en respuestas HTTP estructuradas
```

## **ğŸ“ˆ 9. MÃ‰TRICAS Y MONITOREO**

```typescript
// Ejemplo de como agregar mÃ©tricas
@Injectable()
export class UserService {
  
  async createUser(createDto: CreateUserDto): Promise<User1> {
    const startTime = Date.now();
    
    try {
      const result = await this.userRepository.create(createDto);
      
      // Log de Ã©xito
      console.log(`User created successfully in ${Date.now() - startTime}ms`, {
        email: createDto.email,
        role: createDto.role
      });
      
      return result;
    } catch (error) {
      // Log de error
      console.error(`Failed to create user in ${Date.now() - startTime}ms`, {
        email: createDto.email,
        error: error.message
      });
      
      throw error;
    }
  }
}
```

## **ğŸ¯ 10. RESUMEN DE COMPONENTES**

### **ğŸ“‚ Domain Layer (Dominio)**
- **User Entity**: Representa el concepto de usuario en el negocio
- **IUserRepository Interface**: Define operaciones necesarias para usuarios
- **LÃ³gica de negocio**: MÃ©todos como `isAdmin()`, `canModerate()`

### **ğŸ“‚ Application Layer (AplicaciÃ³n)**
- **UserService**: Orquesta casos de uso del negocio
- **DTOs**: Definen estructura de datos de entrada/salida
- **Validaciones**: Reglas de negocio y validaciones

### **ğŸ“‚ Infrastructure Layer (Infraestructura)**
- **Controllers**: Maneja requests HTTP y responses
- **PrismaUserRepository**: ImplementaciÃ³n especÃ­fica para base de datos
- **Error Handling**: Manejo especÃ­fico de errores de infraestructura

### **ğŸ“‚ Module Configuration**
- **Dependency Injection**: ConfiguraciÃ³n de servicios y repositorios
- **Exports**: QuÃ© servicios estÃ¡n disponibles para otros mÃ³dulos
- **Imports**: QuÃ© mÃ³dulos externos necesitamos

---

Esta arquitectura te da una base sÃ³lida, escalable y mantenible para manejar usuarios en cualquier aplicaciÃ³n NestJS. Cada componente tiene una responsabilidad especÃ­fica y estÃ¡ desacoplado de los demÃ¡s, lo que facilita el testing, mantenimiento y evoluciÃ³n del cÃ³digo.
