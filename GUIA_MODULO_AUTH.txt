# ğŸ” **GuÃ­a Completa: MÃ³dulo de AutenticaciÃ³n NestJS - Paso a Paso**

Te explico cÃ³mo funciona todo el mÃ³dulo de autenticaciÃ³n que hemos construido, con JWT, guards avanzados, decoradores, filtros de errores y logging.

## **ğŸ—ï¸ 1. ARQUITECTURA GENERAL**

```
src/auth/
â”œâ”€â”€ auth.module.ts                    # MÃ³dulo principal de autenticaciÃ³n
â”œâ”€â”€ index.ts                          # Barrel exports para importaciÃ³n limpia
â”œâ”€â”€ constants.ts                      # Constantes (JWT secret, roles, etc.)
â”œâ”€â”€ enums/
â”‚   â””â”€â”€ role.enum.ts                  # Enum de roles (USER, ADMIN, MODERATOR)
â”œâ”€â”€ services/
â”‚   â””â”€â”€ auth.service.ts               # LÃ³gica de autenticaciÃ³n y JWT
â”œâ”€â”€ guards/
â”‚   â”œâ”€â”€ auth.guard.ts                 # Guard global de autenticaciÃ³n JWT
â”‚   â””â”€â”€ role.guard.ts                 # Guard de autorizaciÃ³n por roles
â”œâ”€â”€ decorators/
â”‚   â”œâ”€â”€ public.decorator.ts           # Decorator @Public() para endpoints pÃºblicos
â”‚   â”œâ”€â”€ roles.decorator.ts            # Decorator @Roles() para autorizaciÃ³n
â”‚   â””â”€â”€ custom-error.decorator.ts     # Decorator para mensajes de error personalizados
â”œâ”€â”€ filters/
â”‚   â””â”€â”€ auth-exception.filter.ts      # Filtro global para errores de auth
â””â”€â”€ interceptors/
    â””â”€â”€ auth-logging.interceptor.ts   # Interceptor para logging de acceso
```

## **ğŸ” 2. PRINCIPIOS ARQUITECTÃ“NICOS APLICADOS**

### **A. Guard-Based Security Architecture**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      HTTP REQUEST       â”‚ â† Request entrante
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     AUTH GUARD          â”‚ â† VerificaciÃ³n JWT + @Public()
â”‚   (Global Security)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     ROLE GUARD          â”‚ â† VerificaciÃ³n de roles + @Roles()
â”‚   (Authorization)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     CONTROLLER          â”‚ â† Endpoint ejecutado
â”‚   (Business Logic)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **B. Cross-Cutting Concerns (Aspectos Transversales)**
- **Authentication**: JWT verification en cada request
- **Authorization**: Role-based access control
- **Error Handling**: Respuestas estructuradas y consistentes
- **Logging**: AuditorÃ­a de accesos y fallos de seguridad
- **Decorators**: Metadatos para configurar comportamiento

## **ğŸ“‹ 3. PASO A PASO: CONSTRUCCIÃ“N DEL MÃ“DULO**

### **Paso 1: Definir Constantes y Enums**

```typescript
// constants.ts
// Centraliza todas las constantes del mÃ³dulo de auth

export const jwtConstants = {
  secret: process.env.JWT_SECRET || 'defaultSecretKey123', // âš ï¸ En producciÃ³n usar variable de entorno
  expiresIn: '24h', // Token expira en 24 horas
};

// Mensajes de error consistentes
export const AUTH_MESSAGES = {
  INVALID_TOKEN: 'Token de autenticaciÃ³n invÃ¡lido o expirado',
  NO_TOKEN: 'Token de autenticaciÃ³n requerido',
  INSUFFICIENT_PERMISSIONS: 'Permisos insuficientes para acceder a este recurso',
  USER_NOT_FOUND: 'Usuario no encontrado en el sistema',
  INVALID_CREDENTIALS: 'Credenciales invÃ¡lidas',
  UNAUTHORIZED_ACCESS: 'Acceso no autorizado',
  FORBIDDEN_RESOURCE: 'Recurso prohibido para tu nivel de acceso',
} as const;

// Metadatos para decoradores
export const IS_PUBLIC_KEY = 'isPublic';
export const ROLES_KEY = 'roles';
export const CUSTOM_ERROR_KEY = 'customError';
```

```typescript
// enums/role.enum.ts
// Define los roles disponibles en el sistema

export enum Role {
  USER = 'user',           // ğŸ‘¤ Usuario bÃ¡sico
  MODERATOR = 'moderator', // ğŸ›¡ï¸ Moderador con permisos especiales
  ADMIN = 'admin',         // ğŸ‘‘ Administrador con todos los permisos
}

// Helper functions para trabajar con roles
export class RoleUtils {
  
  // ğŸ” Verificar si un rol tiene permisos de administrador
  static isAdmin(role: string): boolean {
    return role === Role.ADMIN;
  }

  // ğŸ” Verificar si un rol puede moderar
  static canModerate(role: string): boolean {
    return role === Role.ADMIN || role === Role.MODERATOR;
  }

  // ğŸ” Verificar si un rol es vÃ¡lido
  static isValidRole(role: string): boolean {
    return Object.values(Role).includes(role as Role);
  }

  // ğŸ“‹ Obtener todos los roles disponibles
  static getAllRoles(): Role[] {
    return Object.values(Role);
  }

  // ğŸ“Š Obtener jerarquÃ­a de roles (mayor a menor privilegio)
  static getRoleHierarchy(): Role[] {
    return [Role.ADMIN, Role.MODERATOR, Role.USER];
  }
}
```

### **Paso 2: Crear el Servicio de AutenticaciÃ³n**

```typescript
// services/auth.service.ts
// Maneja toda la lÃ³gica de autenticaciÃ³n con JWT

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService, // Para validar usuarios
    private readonly jwtService: JwtService,   // Para crear/verificar tokens
  ) {}

  // ğŸ” LOGIN: Autenticar usuario y generar JWT
  async signIn(email: string, password: string): Promise<{ access_token: string; user: any }> {
    try {
      // 1. ğŸ” Buscar usuario por email
      const user = await this.userService.findByEmail(email);
      
      // 2. ğŸ”’ Verificar contraseÃ±a (en producciÃ³n usar bcrypt)
      if (user.password !== password) {
        throw new UnauthorizedException(AUTH_MESSAGES.INVALID_CREDENTIALS);
      }

      // 3. ğŸ« Crear payload para JWT
      const payload = { 
        sub: user.id,        // Subject (ID del usuario)
        username: user.email, // Username (email)
        role: user.role      // Role para autorizaciÃ³n
      };

      // 4. ğŸ­ Generar token JWT
      const access_token = await this.jwtService.signAsync(payload, {
        secret: jwtConstants.secret,
        expiresIn: jwtConstants.expiresIn,
      });

      // 5. ğŸ“¤ Retornar token y datos del usuario (sin password)
      return {
        access_token,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          avatarUrl: user.avatarUrl,
        }
      };

    } catch (error) {
      // ğŸš¨ Manejo de errores especÃ­ficos
      if (error instanceof NotFoundException) {
        throw new UnauthorizedException(AUTH_MESSAGES.INVALID_CREDENTIALS);
      }
      throw error;
    }
  }

  // ğŸ” VALIDATE USER: Validar usuario desde token JWT
  async validateUser(payload: any): Promise<any> {
    try {
      // 1. ğŸ” Buscar usuario por ID del payload
      const user = await this.userService.findById(payload.sub);
      
      // 2. âœ… Retornar datos del usuario para el request
      return {
        userId: user.id,
        username: user.email,
        role: user.role,
        name: user.name,
      };
    } catch (error) {
      // ğŸš¨ Si el usuario no existe, el token es invÃ¡lido
      throw new UnauthorizedException(AUTH_MESSAGES.USER_NOT_FOUND);
    }
  }

  // ğŸ”„ REFRESH TOKEN: Generar nuevo token (opcional)
  async refreshToken(oldToken: string): Promise<{ access_token: string }> {
    try {
      // 1. ğŸ” Verificar token actual
      const payload = await this.jwtService.verifyAsync(oldToken, {
        secret: jwtConstants.secret,
      });

      // 2. ğŸ« Crear nuevo payload
      const newPayload = { 
        sub: payload.sub,
        username: payload.username,
        role: payload.role
      };

      // 3. ğŸ­ Generar nuevo token
      const access_token = await this.jwtService.signAsync(newPayload, {
        secret: jwtConstants.secret,
        expiresIn: jwtConstants.expiresIn,
      });

      return { access_token };
    } catch (error) {
      throw new UnauthorizedException(AUTH_MESSAGES.INVALID_TOKEN);
    }
  }

  // ğŸ§ª VERIFY TOKEN: Verificar si un token es vÃ¡lido
  async verifyToken(token: string): Promise<any> {
    try {
      return await this.jwtService.verifyAsync(token, {
        secret: jwtConstants.secret,
      });
    } catch (error) {
      throw new UnauthorizedException(AUTH_MESSAGES.INVALID_TOKEN);
    }
  }
}
```

### **Paso 3: Crear Decoradores Personalizados**

```typescript
// decorators/public.decorator.ts
// Marca endpoints que no requieren autenticaciÃ³n

import { SetMetadata } from '@nestjs/common';
import { IS_PUBLIC_KEY } from '../constants';

// ğŸ”“ Decorator @Public() - Permite acceso sin autenticaciÃ³n
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

// âœ¨ Uso:
// @Public()
// @Get('info')
// getPublicInfo() { ... }
```

```typescript
// decorators/roles.decorator.ts
// Marca endpoints que requieren roles especÃ­ficos

import { SetMetadata } from '@nestjs/common';
import { Role } from '../enums/role.enum';
import { ROLES_KEY } from '../constants';

// ğŸ‘‘ Decorator @Roles() - Especifica roles requeridos
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);

// âœ¨ Uso:
// @Roles(Role.ADMIN)
// @Get('admin-data')
// getAdminData() { ... }
//
// @Roles(Role.ADMIN, Role.MODERATOR)
// @Get('moderate')
// moderate() { ... }
```

```typescript
// decorators/custom-error.decorator.ts
// Permite personalizar mensajes de error de autenticaciÃ³n

import { SetMetadata } from '@nestjs/common';
import { CUSTOM_ERROR_KEY } from '../constants';

// ğŸ¨ Interface para mensajes personalizados
export interface CustomAuthError {
  unauthorized?: string;  // Mensaje para 401 Unauthorized
  forbidden?: string;     // Mensaje para 403 Forbidden
}

// ğŸ¨ Decorator @CustomError() - Personaliza mensajes de error
export const CustomError = (errors: CustomAuthError) => 
  SetMetadata(CUSTOM_ERROR_KEY, errors);

// âœ¨ Uso:
// @CustomError({
//   unauthorized: 'Necesitas estar logueado para ver esta informaciÃ³n',
//   forbidden: 'Solo administradores pueden acceder a este panel'
// })
// @Roles(Role.ADMIN)
// @Get('admin-panel')
// getAdminPanel() { ... }
```

### **Paso 4: Crear Guards de Seguridad**

```typescript
// guards/auth.guard.ts
// Guard global que verifica autenticaciÃ³n JWT

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private readonly jwtService: JwtService,
    private readonly authService: AuthService,
    private readonly reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // 1. ğŸ” Verificar si el endpoint es pÃºblico
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      // âœ… Endpoint pÃºblico - permitir acceso sin autenticaciÃ³n
      return true;
    }

    // 2. ğŸ“¥ Extraer request y token
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      // ğŸš¨ No hay token - obtener mensaje personalizado si existe
      const customError = this.reflector.get<CustomAuthError>(
        CUSTOM_ERROR_KEY,
        context.getHandler(),
      );
      
      const message = customError?.unauthorized || AUTH_MESSAGES.NO_TOKEN;
      throw new UnauthorizedException(message);
    }

    try {
      // 3. ğŸ” Verificar y decodificar token
      const payload = await this.jwtService.verifyAsync(token, {
        secret: jwtConstants.secret,
      });

      // 4. ğŸ‘¤ Validar usuario y obtener datos actuales
      const user = await this.authService.validateUser(payload);

      // 5. âœ… Adjuntar usuario al request para uso posterior
      request['user'] = user;

      return true;
    } catch (error) {
      // ğŸš¨ Token invÃ¡lido - obtener mensaje personalizado si existe
      const customError = this.reflector.get<CustomAuthError>(
        CUSTOM_ERROR_KEY,
        context.getHandler(),
      );
      
      const message = customError?.unauthorized || AUTH_MESSAGES.INVALID_TOKEN;
      throw new UnauthorizedException(message);
    }
  }

  // ğŸ”§ Helper: Extraer token del header Authorization
  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers['authorization']?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

```typescript
// guards/role.guard.ts
// Guard que verifica autorizaciÃ³n por roles

@Injectable()
export class RoleGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    // 1. ğŸ” Verificar si el endpoint es pÃºblico
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      // âœ… Endpoint pÃºblico - no verificar roles
      return true;
    }

    // 2. ğŸ“‹ Obtener roles requeridos del decorator @Roles()
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      // âœ… No hay roles especÃ­ficos requeridos - solo autenticaciÃ³n
      return true;
    }

    // 3. ğŸ‘¤ Obtener usuario del request (adjuntado por AuthGuard)
    const { user } = context.switchToHttp().getRequest();

    if (!user) {
      // ğŸš¨ No hay usuario autenticado (no deberÃ­a pasar si AuthGuard funciona)
      throw new UnauthorizedException(AUTH_MESSAGES.UNAUTHORIZED_ACCESS);
    }

    // 4. ğŸ” Verificar si el usuario tiene alguno de los roles requeridos
    const hasRole = requiredRoles.some((role) => user.role === role);

    if (!hasRole) {
      // ğŸš¨ Usuario no tiene rol suficiente - obtener mensaje personalizado
      const customError = this.reflector.get<CustomAuthError>(
        CUSTOM_ERROR_KEY,
        context.getHandler(),
      );
      
      const message = customError?.forbidden || 
        `Se requiere uno de los siguientes roles: ${requiredRoles.join(', ')}`;
      
      throw new ForbiddenException(message);
    }

    // âœ… Usuario tiene rol suficiente
    return true;
  }
}
```

### **Paso 5: Crear Filtro de Excepciones**

```typescript
// filters/auth-exception.filter.ts
// Filtro global para manejar errores de autenticaciÃ³n y autorizaciÃ³n

@Catch(UnauthorizedException, ForbiddenException)
export class AuthExceptionFilter implements ExceptionFilter {
  catch(exception: UnauthorizedException | ForbiddenException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // ğŸ¯ Determinar cÃ³digo de estado HTTP
    const status = exception.getStatus();
    
    // ğŸ“ Crear respuesta estructurada
    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      error: {
        type: exception.name,
        message: exception.message,
        details: this.getErrorDetails(status),
      },
      // ğŸ” InformaciÃ³n adicional para debugging (solo en desarrollo)
      ...(process.env.NODE_ENV === 'development' && {
        stack: exception.stack,
        cause: exception.cause,
      }),
    };

    // ğŸ“Š Log del error para auditorÃ­a
    console.error(`[AuthExceptionFilter] ${status} - ${exception.message}`, {
      path: request.url,
      method: request.method,
      userAgent: request.headers['user-agent'],
      timestamp: errorResponse.timestamp,
    });

    // ğŸ“¤ Enviar respuesta estructurada
    response.status(status).json(errorResponse);
  }

  // ğŸ”§ Helper: Obtener detalles especÃ­ficos segÃºn el tipo de error
  private getErrorDetails(status: number): any {
    switch (status) {
      case 401:
        return {
          code: 'UNAUTHORIZED',
          suggestion: 'Verifica que estÃ©s enviando un token vÃ¡lido en el header Authorization',
          authHeader: 'Authorization: Bearer <tu-jwt-token>',
        };
      case 403:
        return {
          code: 'FORBIDDEN',
          suggestion: 'Tu usuario no tiene permisos suficientes para acceder a este recurso',
          contactInfo: 'Contacta al administrador si crees que esto es un error',
        };
      default:
        return {
          code: 'AUTH_ERROR',
          suggestion: 'Error de autenticaciÃ³n o autorizaciÃ³n',
        };
    }
  }
}
```

### **Paso 6: Crear Interceptor de Logging**

```typescript
// interceptors/auth-logging.interceptor.ts
// Interceptor para logging de accesos y auditorÃ­a de seguridad

@Injectable()
export class AuthLoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const { method, url, headers, user } = request;
    
    // ğŸ“ InformaciÃ³n del request
    const requestInfo = {
      method,
      url,
      userAgent: headers['user-agent'],
      ip: request.ip || request.connection.remoteAddress,
      timestamp: new Date().toISOString(),
      // ğŸ‘¤ InformaciÃ³n del usuario autenticado (si existe)
      user: user ? {
        id: user.userId,
        email: user.username,
        role: user.role,
      } : null,
    };

    // â±ï¸ Tiempo de inicio para medir duraciÃ³n
    const startTime = Date.now();

    // ğŸ“Š Log de acceso
    console.log(`[AUTH ACCESS] ${method} ${url}`, requestInfo);

    return next.handle().pipe(
      tap(() => {
        // âœ… Log de Ã©xito
        const duration = Date.now() - startTime;
        console.log(`[AUTH SUCCESS] ${method} ${url} - ${duration}ms`, {
          ...requestInfo,
          duration,
          status: 'success',
        });
      }),
      catchError((error) => {
        // ğŸš¨ Log de error
        const duration = Date.now() - startTime;
        console.error(`[AUTH ERROR] ${method} ${url} - ${duration}ms`, {
          ...requestInfo,
          duration,
          status: 'error',
          error: {
            name: error.name,
            message: error.message,
          },
        });
        
        // Re-throw el error para que continÃºe el flujo normal
        throw error;
      }),
    );
  }
}
```

### **Paso 7: Crear Barrel Exports (index.ts)**

```typescript
// index.ts
// Centraliza todas las exportaciones del mÃ³dulo para importaciÃ³n limpia

// ğŸ­ Servicios
export { AuthService } from './services/auth.service';

// ğŸ›¡ï¸ Guards
export { AuthGuard } from './guards/auth.guard';
export { RoleGuard } from './guards/role.guard';

// ğŸ¨ Decoradores
export { Public } from './decorators/public.decorator';
export { Roles } from './decorators/roles.decorator';
export { CustomError, CustomAuthError } from './decorators/custom-error.decorator';

// ğŸ“Š Enums y tipos
export { Role, RoleUtils } from './enums/role.enum';

// ğŸ”§ Constantes
export { jwtConstants, AUTH_MESSAGES } from './constants';

// ğŸš¨ Filtros e interceptores
export { AuthExceptionFilter } from './filters/auth-exception.filter';
export { AuthLoggingInterceptor } from './interceptors/auth-logging.interceptor';

// ğŸ“¦ MÃ³dulo principal
export { AuthModule } from './auth.module';

// âœ¨ Ventajas del barrel export:
// 1. ImportaciÃ³n limpia: import { AuthGuard, Roles } from '@/auth'
// 2. EncapsulaciÃ³n: Solo exportamos lo que queremos que sea pÃºblico
// 3. Refactoring: Cambios internos no afectan importaciones externas
```

### **Paso 8: Configurar el MÃ³dulo**

```typescript
// auth.module.ts
// Ensambla todos los componentes del mÃ³dulo de autenticaciÃ³n

@Module({
  imports: [
    // ğŸ”‘ ConfiguraciÃ³n de JWT
    JwtModule.register({
      global: true,                    // JWT disponible globalmente
      secret: jwtConstants.secret,     // Clave secreta
      signOptions: { 
        expiresIn: jwtConstants.expiresIn // Tiempo de expiraciÃ³n
      },
    }),
    // ğŸ‘¥ Acceso al mÃ³dulo de usuarios
    forwardRef(() => UserModule),     // Referencia circular con UserModule
  ],
  providers: [
    AuthService,                      // Servicio de autenticaciÃ³n
    {
      provide: APP_GUARD,             // ğŸ›¡ï¸ Guard global de autenticaciÃ³n
      useClass: AuthGuard,
    },
    {
      provide: APP_GUARD,             // ğŸ›¡ï¸ Guard global de roles (ejecuta despuÃ©s de AuthGuard)
      useClass: RoleGuard,
    },
    {
      provide: APP_FILTER,            // ğŸš¨ Filtro global de excepciones de auth
      useClass: AuthExceptionFilter,
    },
    {
      provide: APP_INTERCEPTOR,       // ğŸ“Š Interceptor global de logging
      useClass: AuthLoggingInterceptor,
    },
  ],
  exports: [
    AuthService,                      // Para usar en otros mÃ³dulos
    JwtService,                       // Para acceso directo si es necesario
  ],
})
export class AuthModule {}

// âœ¨ ConfiguraciÃ³n global significa:
// - AuthGuard y RoleGuard se aplican automÃ¡ticamente a TODOS los endpoints
// - AuthExceptionFilter maneja TODOS los errores de auth
// - AuthLoggingInterceptor registra TODOS los accesos
// - Solo endpoints con @Public() se saltan la autenticaciÃ³n
```

## **ğŸ”„ 4. FLUJO COMPLETO DE AUTENTICACIÃ“N**

### **Ejemplo: Acceso a endpoint protegido con roles**

```
1. ğŸ“¥ GET /admin/users
   Headers: { "Authorization": "Bearer eyJhbGciOiJIUzI1NiIs..." }

2. ğŸ“Š AuthLoggingInterceptor registra el acceso:
   â”œâ”€â”€ IP, User-Agent, timestamp
   â””â”€â”€ Log: "[AUTH ACCESS] GET /admin/users"

3. ğŸ” AuthGuard verifica:
   â”œâ”€â”€ Â¿Tiene @Public()? â†’ NO âŒ
   â”œâ”€â”€ Â¿Hay token en header? â†’ SÃ âœ…
   â”œâ”€â”€ Â¿Token es vÃ¡lido? â†’ SÃ âœ…
   â”œâ”€â”€ Â¿Usuario existe? â†’ SÃ âœ…
   â””â”€â”€ Adjunta user al request: req.user = { userId: "123", username: "admin@test.com", role: "admin" }

4. ğŸ›¡ï¸ RoleGuard verifica:
   â”œâ”€â”€ Â¿Tiene @Public()? â†’ NO âŒ
   â”œâ”€â”€ Â¿Requiere roles especÃ­ficos? â†’ SÃ âœ… @Roles(Role.ADMIN)
   â”œâ”€â”€ Â¿Usuario tiene rol admin? â†’ SÃ âœ…
   â””â”€â”€ Permite continuar

5. ğŸ¯ Controller.getUsers() se ejecuta:
   â”œâ”€â”€ Acceso a req.user.username y req.user.role
   â””â”€â”€ Retorna datos

6. ğŸ“Š AuthLoggingInterceptor registra Ã©xito:
   â””â”€â”€ Log: "[AUTH SUCCESS] GET /admin/users - 45ms"

7. ğŸ“¤ Respuesta se envÃ­a al cliente:
   {
     "users": [...],
     "requestedBy": "admin@test.com",
     "requestedAt": "2025-07-14T10:30:00.000Z"
   }
```

### **Ejemplo: Error de autorizaciÃ³n**

```
1. ğŸ“¥ GET /admin/users
   Headers: { "Authorization": "Bearer token-de-usuario-normal" }

2. ğŸ” AuthGuard verifica:
   â”œâ”€â”€ Token vÃ¡lido âœ…
   â””â”€â”€ req.user = { userId: "456", username: "user@test.com", role: "user" }

3. ğŸ›¡ï¸ RoleGuard verifica:
   â”œâ”€â”€ Requiere roles: [Role.ADMIN] âœ…
   â”œâ”€â”€ Usuario tiene rol: "user" âŒ
   â””â”€â”€ Throw ForbiddenException("Se requiere uno de los siguientes roles: admin")

4. ğŸš¨ AuthExceptionFilter captura:
   â”œâ”€â”€ Status: 403 Forbidden
   â”œâ”€â”€ Crea respuesta estructurada
   â””â”€â”€ Log: "[AuthExceptionFilter] 403 - Se requiere uno de los siguientes roles: admin"

5. ğŸ“¤ Respuesta de error se envÃ­a:
   {
     "statusCode": 403,
     "timestamp": "2025-07-14T10:30:00.000Z",
     "path": "/admin/users",
     "method": "GET",
     "error": {
       "type": "ForbiddenException",
       "message": "Se requiere uno de los siguientes roles: admin",
       "details": {
         "code": "FORBIDDEN",
         "suggestion": "Tu usuario no tiene permisos suficientes..."
       }
     }
   }
```

## **ğŸ¯ 5. VENTAJAS DE ESTA ARQUITECTURA**

### **âœ… Seguridad Robusta**
- **JWT Stateless**: No necesitamos sesiones en servidor
- **Guards Globales**: ProtecciÃ³n automÃ¡tica en todos los endpoints
- **Role-Based Access**: Control granular de permisos
- **Error Handling**: Mensajes consistentes y seguros

### **âœ… Flexibilidad y Configurabilidad**
```typescript
// FÃ¡cil marcar endpoints como pÃºblicos
@Public()
@Get('health')
getHealth() { ... }

// FÃ¡cil especificar roles requeridos
@Roles(Role.ADMIN, Role.MODERATOR)
@Get('moderate')
moderate() { ... }

// FÃ¡cil personalizar mensajes de error
@CustomError({
  unauthorized: 'Necesitas estar logueado',
  forbidden: 'Solo admins pueden ver esto'
})
@Roles(Role.ADMIN)
@Get('secret')
getSecret() { ... }
```

### **âœ… Observabilidad y AuditorÃ­a**
- **Logging AutomÃ¡tico**: Todos los accesos se registran
- **Error Tracking**: Errores estructurados para anÃ¡lisis
- **MÃ©tricas**: Tiempo de respuesta y patrones de uso
- **Security Audit**: Intentos de acceso no autorizado

### **âœ… Mantenibilidad**
- **SeparaciÃ³n de Responsabilidades**: Cada componente tiene un propÃ³sito especÃ­fico
- **ReutilizaciÃ³n**: Guards y decoradores reutilizables
- **Testing**: Componentes isolados fÃ¡ciles de testear
- **EvoluciÃ³n**: FÃ¡cil agregar nuevos roles o funcionalidades

## **ğŸ”§ 6. PATRONES DE DISEÃ‘O UTILIZADOS**

### **Guard Pattern**
```typescript
// VerificaciÃ³n de condiciones antes de ejecutar lÃ³gica
@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean | Promise<boolean> {
    // LÃ³gica de verificaciÃ³n
    return this.isAuthorized(context);
  }
}
```

### **Decorator Pattern**
```typescript
// Metadatos para modificar comportamiento
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);
```

### **Strategy Pattern**
```typescript
// Diferentes estrategias de autenticaciÃ³n (JWT, OAuth, etc.)
interface AuthStrategy {
  validate(payload: any): Promise<any>;
}

class JwtStrategy implements AuthStrategy {
  async validate(payload: any): Promise<any> {
    return await this.userService.findById(payload.sub);
  }
}
```

### **Filter Pattern**
```typescript
// Filtrado y manejo especÃ­fico de excepciones
@Catch(UnauthorizedException, ForbiddenException)
export class AuthExceptionFilter implements ExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    // Manejo especÃ­fico
  }
}
```

### **Interceptor Pattern**
```typescript
// Aspecto transversal (logging, mÃ©tricas, etc.)
export class AuthLoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    // LÃ³gica antes y despuÃ©s de la ejecuciÃ³n
    return next.handle().pipe(/* transformaciones */);
  }
}
```

## **ğŸ“Š 7. EJEMPLO DE TESTING**

```typescript
// auth.service.spec.ts
describe('AuthService', () => {
  let service: AuthService;
  let mockUserService: jest.Mocked<UserService>;
  let mockJwtService: jest.Mocked<JwtService>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: UserService,
          useValue: {
            findByEmail: jest.fn(),
            findById: jest.fn(),
          },
        },
        {
          provide: JwtService,
          useValue: {
            signAsync: jest.fn(),
            verifyAsync: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    mockUserService = module.get(UserService);
    mockJwtService = module.get(JwtService);
  });

  describe('signIn', () => {
    it('should return access token when credentials are valid', async () => {
      // Arrange
      const email = 'test@example.com';
      const password = 'password123';
      const mockUser = {
        id: 'user-id',
        email,
        password,
        role: 'user',
        name: 'Test User',
      };

      mockUserService.findByEmail.mockResolvedValue(mockUser);
      mockJwtService.signAsync.mockResolvedValue('jwt-token');

      // Act
      const result = await service.signIn(email, password);

      // Assert
      expect(result).toEqual({
        access_token: 'jwt-token',
        user: {
          id: 'user-id',
          email,
          name: 'Test User',
          role: 'user',
          avatarUrl: undefined,
        }
      });
      expect(mockUserService.findByEmail).toHaveBeenCalledWith(email);
      expect(mockJwtService.signAsync).toHaveBeenCalledWith(
        { sub: 'user-id', username: email, role: 'user' },
        { secret: jwtConstants.secret, expiresIn: jwtConstants.expiresIn }
      );
    });

    it('should throw UnauthorizedException when password is invalid', async () => {
      // Arrange
      const email = 'test@example.com';
      const password = 'wrong-password';
      const mockUser = {
        id: 'user-id',
        email,
        password: 'correct-password',
        role: 'user',
        name: 'Test User',
      };

      mockUserService.findByEmail.mockResolvedValue(mockUser);

      // Act & Assert
      await expect(service.signIn(email, password)).rejects.toThrow(
        UnauthorizedException
      );
      expect(mockJwtService.signAsync).not.toHaveBeenCalled();
    });
  });
});
```

```typescript
// auth.guard.spec.ts
describe('AuthGuard', () => {
  let guard: AuthGuard;
  let mockJwtService: jest.Mocked<JwtService>;
  let mockAuthService: jest.Mocked<AuthService>;
  let mockReflector: jest.Mocked<Reflector>;

  beforeEach(() => {
    mockJwtService = {
      verifyAsync: jest.fn(),
    } as any;

    mockAuthService = {
      validateUser: jest.fn(),
    } as any;

    mockReflector = {
      getAllAndOverride: jest.fn(),
      get: jest.fn(),
    } as any;

    guard = new AuthGuard(mockJwtService, mockAuthService, mockReflector);
  });

  it('should allow access to public endpoints', async () => {
    // Arrange
    const context = createMockExecutionContext();
    mockReflector.getAllAndOverride.mockReturnValue(true); // isPublic = true

    // Act
    const result = await guard.canActivate(context);

    // Assert
    expect(result).toBe(true);
    expect(mockJwtService.verifyAsync).not.toHaveBeenCalled();
  });

  it('should throw UnauthorizedException when no token provided', async () => {
    // Arrange
    const context = createMockExecutionContext({
      headers: {}, // No Authorization header
    });
    mockReflector.getAllAndOverride.mockReturnValue(false); // isPublic = false

    // Act & Assert
    await expect(guard.canActivate(context)).rejects.toThrow(
      UnauthorizedException
    );
  });

  it('should allow access when valid token provided', async () => {
    // Arrange
    const context = createMockExecutionContext({
      headers: {
        authorization: 'Bearer valid-jwt-token',
      },
    });
    
    mockReflector.getAllAndOverride.mockReturnValue(false); // isPublic = false
    mockJwtService.verifyAsync.mockResolvedValue({
      sub: 'user-id',
      username: 'test@example.com',
      role: 'user',
    });
    mockAuthService.validateUser.mockResolvedValue({
      userId: 'user-id',
      username: 'test@example.com',
      role: 'user',
    });

    // Act
    const result = await guard.canActivate(context);

    // Assert
    expect(result).toBe(true);
    expect(mockJwtService.verifyAsync).toHaveBeenCalledWith(
      'valid-jwt-token',
      { secret: jwtConstants.secret }
    );
  });
});

// Helper function para crear mock execution context
function createMockExecutionContext(requestData: any = {}) {
  const mockRequest = {
    headers: {},
    ...requestData,
  };

  return {
    switchToHttp: () => ({
      getRequest: () => mockRequest,
    }),
    getHandler: () => ({}),
    getClass: () => ({}),
  } as any;
}
```

## **ğŸš¨ 8. MANEJO AVANZADO DE ERRORES**

### **Errores EspecÃ­ficos por SituaciÃ³n**
```typescript
// En AuthService
if (user.password !== password) {
  throw new UnauthorizedException(AUTH_MESSAGES.INVALID_CREDENTIALS);
}

// En AuthGuard
if (!token) {
  const customError = this.reflector.get<CustomAuthError>(CUSTOM_ERROR_KEY, context.getHandler());
  const message = customError?.unauthorized || AUTH_MESSAGES.NO_TOKEN;
  throw new UnauthorizedException(message);
}

// En RoleGuard
if (!hasRole) {
  const customError = this.reflector.get<CustomAuthError>(CUSTOM_ERROR_KEY, context.getHandler());
  const message = customError?.forbidden || `Se requiere uno de los siguientes roles: ${requiredRoles.join(', ')}`;
  throw new ForbiddenException(message);
}
```

### **Respuestas Estructuradas**
```typescript
// AuthExceptionFilter genera respuestas consistentes
{
  "statusCode": 401,
  "timestamp": "2025-07-14T10:30:00.000Z",
  "path": "/admin/users",
  "method": "GET",
  "error": {
    "type": "UnauthorizedException",
    "message": "Token de autenticaciÃ³n invÃ¡lido o expirado",
    "details": {
      "code": "UNAUTHORIZED",
      "suggestion": "Verifica que estÃ©s enviando un token vÃ¡lido en el header Authorization",
      "authHeader": "Authorization: Bearer <tu-jwt-token>"
    }
  }
}
```

## **ğŸ“ˆ 9. MÃ‰TRICAS Y MONITOREO**

### **Logging AutomÃ¡tico**
```typescript
// AuthLoggingInterceptor registra automÃ¡ticamente:
console.log(`[AUTH ACCESS] GET /admin/users`, {
  method: 'GET',
  url: '/admin/users',
  userAgent: 'Mozilla/5.0...',
  ip: '192.168.1.100',
  timestamp: '2025-07-14T10:30:00.000Z',
  user: {
    id: 'user-123',
    email: 'admin@test.com',
    role: 'admin'
  }
});

console.log(`[AUTH SUCCESS] GET /admin/users - 45ms`, {
  duration: 45,
  status: 'success',
  // ... resto de informaciÃ³n
});
```

### **MÃ©tricas de Seguridad**
```typescript
// Ejemplos de mÃ©tricas que puedes extraer:
// - Intentos de login fallidos por IP
// - Endpoints mÃ¡s accedidos por rol
// - Tokens expirados o invÃ¡lidos
// - Tiempos de respuesta por endpoint protegido
// - Patrones de acceso sospechosos
```

## **ğŸ¯ 10. RESUMEN DE COMPONENTES**

### **ğŸ“‚ Core Authentication**
- **AuthService**: Login, validaciÃ³n de usuarios, generaciÃ³n de JWT
- **AuthGuard**: VerificaciÃ³n global de autenticaciÃ³n
- **JwtStrategy**: ConfiguraciÃ³n y validaciÃ³n de tokens JWT

### **ğŸ“‚ Authorization & Roles**
- **RoleGuard**: VerificaciÃ³n de permisos por roles
- **Role Enum**: DefiniciÃ³n de roles del sistema
- **@Roles Decorator**: Especificar roles requeridos en endpoints

### **ğŸ“‚ Error Handling**
- **AuthExceptionFilter**: Manejo global de errores de auth
- **CustomError Decorator**: PersonalizaciÃ³n de mensajes de error
- **Structured Responses**: Respuestas consistentes y informativas

### **ğŸ“‚ Observability**
- **AuthLoggingInterceptor**: Logging automÃ¡tico de accesos
- **Security Audit**: Registro de intentos de acceso
- **Performance Metrics**: Tiempos de respuesta y uso

### **ğŸ“‚ Developer Experience**
- **@Public Decorator**: Marcar endpoints pÃºblicos fÃ¡cilmente
- **Barrel Exports**: Importaciones limpias y organizadas
- **TypeScript Support**: Tipado fuerte y autocompletado
- **Testing Support**: Componentes testeable y mockeable

---

Esta arquitectura de autenticaciÃ³n te proporciona una seguridad robusta, flexible y mantenible para cualquier aplicaciÃ³n NestJS empresarial. Cada componente estÃ¡ diseÃ±ado para ser modular, testeable y escalable.
